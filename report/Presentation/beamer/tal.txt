Hi, I'm Jonathan and I'm writing my thesis on verification for the Algorithmic Verification Group here at university, with Parosh Abdulla as supervisor. The preliminary name of my thesis is "algorithmic verification of channel Machines using small models", and this will also serve as the outline of my presentation: with only five minutes, I can't go much deeper than explaining the words of the title.

SLIDE

The general definition of verification should be familiar: read it up. Model checking is a technique used for verification. In general, one creates a model describing the behaviour of a program, or a chip or whatever is going to be verified. Then one specifies the inteded properties (i.e. the specification) of the program. Using this, a model checker will automatically check whether the properties are met. This is usually done by building a combined graph of the model and the properties and carry out an exhaustive search of the graph.

SLIDE

A channel system is any system that relies on channels for its operation, for example communication protocols, but it could also be for example be a cache coherence protocol, which uses shared memory and can be modeled with a channel.

This is probably nothing new, but the point I want to make is that if the channel is unbounded, the verification of the system will correspond to searching an infinite graph. There are of course techniques to overcome this problem, the simplest being to just bound the channel to be of a certain size and verify that subproblem. If that subproblem meets the specification, it might be seen as an indication that the program works as intended in general, but it is not a guarantee. This might be enough for some applications, but often, particularly safety-critical systems, a guarantee is vital.

SLIDE

There are of course better techniques, but the verification problem is inherently undecidable, so there are no general techniques for this. Small models is one example of this: for certain classes of problems, I'll not go into exactly which classes, it turns out that a small instance of a verification problem will in fact exhibit all the relevant behaviour of the system as a whole. Therefore, verifying the small instance will guarantee that the results would hold also for any larger instance. This technique is  pretty much equivalent to the simple solution I explained before, with the difference that you actually get a guarantee of correctness.

SLIDE

Having explained the keywords, my thesis is about putting these components together. I create a model in which I can express the behaviour of channel systems, and I create an algorithm to find a small instance of the system that actually does exhibit all the relevant behaviour of the system.

I have also implemented this algorithm, and tested it by verifying several known communication protocols.

SLIDE

What I still need to do is to complete the implementation -- it is working, but doesn't have the full intended scope yet. Further, I'm going to compare the results and the performance of my work with that of other other algorithms that solve the same problem.

Finally, I want to note that the although the verifier might find a guarantee of correctness, it doesn't guarantee that it will find it. There's reason to suspect that there are classes of problems where it is always possible to find such a guarantee, but classifying those problems is unfortunately outside the scope of my project.

Thank you for listening.


