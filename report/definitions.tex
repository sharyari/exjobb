\section{Formal Model for Lossy Channel Systems}
\label{definitions}
In this chapter we will give the formal definition of a channel system. First we define some necessary terminology, such as alphabets and words, before giving the syntax and semantics of a channel system. Then we illustrate these ideas by applying them to a well-known communication protocol, the \emph{alternating bit protocol}. Finally, we state the formal definition of the verification problem we are investigating.

\subsection{Preliminaries}
\subsubsection{Words and Alphabet}
An \emph{alphabet} $\Sigma$ is a finite set of \e{tokens}. A \emph{message} is a possibly empty string of token over an alphabet $\Sigma$, whereas a \e{word} is a sequence of messages, i.e. $w$ = $m_1, m_2..., m_n$ is a word containing the messages $m_1$ to $m_n$. We use the concatenation operator $\bullet$ to append messages, i.e. $w$ $\bullet$ $m_{n+1}$ = $m_1...m_n,m_{n+1}$ = $m_1...m_n \bullet m_{n+1}$.

\todo[inline]{The missing subword ac is not a mistake. I'm not sure I can argue why it should not be there (can't remember if I need it not to be). In case I need to stick with the definition below, should I then use another symbol that $\subword$?}

Let $\subword$ be the subword relation, then \e{u} $\subword$ $s_1...s_n$=\e{w} iff \e{u} is an ordered subset of \e{w}. For example, if \e{w}=abc, then the set of subwords of \e{w} is {abc, ab, bc, a, b, c}.

\subsubsection{Evaluations}
A channel may contain a word on its channel. We use $\xi(ch)$ to denote the \e{evaluation} of a channel $ch$, meaning the word (string of messages) currently on that channel. In essence, this is the same as the current state of the channel, but we do not use this term in order to avoid confusion.

We use $\xi$ without a specified channel to refer to the evaluation of an ordered set of channels. We say that $\xi$ $\subword$ $\xi'$ if for any channel $ch_i$ $\in$ $\xi$ and $ch_i'$ $\in$ $\xi'$, $ch_i$ $\subword$ $ch_i'$

\subsection{??}
Potentially a section on how to read the transition relation notations used below.

\subsection{Lossy Channel Systems}
\subsubsection{Syntax}
We present here the syntax of a finite-state system with unbounded channels. Such a system can be seen as to having two parts, a \e{control part} and a \e{channel part}. The channel part is a set of channels, which may be empty or contain a sequence of messages, a \e{word}. The control part is a labeled finite-state transition system.

\label{CS}
Formally, a channel system \emph{CS} over a set of processes \e{P} and channels \e{Ch} is a tuple $\langle$S,$s_0$,A,C,M,$\delta$$\rangle$, where
\begin{itemize}
\item[]
$S$ is a finite set of control states,
\item[]
$s_0$ $\in$ $S$ is an initial control state,
\item[]
\e{A} is a finite set of actions,
\item[]
\e{Ch} is a finite set of channels,
\item[]
\e{M} is a finite set of messages over a finite alphabet $\Sigma$,
\item[]
$\delta$ is a finite set of transitions, each of which is a triple of the form $\langle s_1,op,s_2\rangle$, where $s_1$ and $s_2$ are control states, and op is a label of one of the forms

\begin{itemize}
\item
\e{ch!m}, where \e{ch} $\in$ \e{Ch} and \e{m} $\in$ \e{M}
\item
\e{ch?m}, where \e{ch} $\in$ \e{Ch} and \e{m} $\in$ \e{M}
\item
\e{a} $\in$ \e{A}.
\end{itemize}
\end{itemize}

The finite-state control part of \e{CS} is an ordinary labeled transition system with states \e{S}, initial state $s_0$ and transitions $\delta$. The channel part is represented by the set \e{Ch} of channels, which may contain a word of messages in \e{M} over the alphabet $\Sigma$. The set \e{A} denotes the set of observable interactions with the environment. $\delta$ may either be an observable action from \e{A}, or an unobservable action, where

\begin{itemize}
\item[]
$\langle s_1, ch!m, s_2\rangle$ represents a change of state from $s_1\in S$ to $s_2\in S$ while appending the message $m\in M$ to the tail of channel $ch\in Ch$.
\item[]
$\langle s_1, ch?m, s_2\rangle$ represents a change of state from $s_1\in S$ to $s_2\in S$ while removing the message $m\in M$ to the head of channel $ch \in Ch$
\end{itemize}

\subsubsection{Configuration}
What to say here?
+Initial configuration

\subsection{Semantics}
In the following section, we explain the semantics of a lossy channel system, which described the behaviour of the system.
%A \e{transition system} is an abstract machine, commonly used in model checking to describe the behaviour of a system. They are in ways similar to the notion of finite state automata, with the difference that the states and transitions in a transition system need not be finite. A state of a transition system describing a program may be determined, for example, the evaluation of all variables in the program. Transitions describe how a system in a certain state can move to another state.

\paragraph{Definition}
\label{CTS}
The operational behaviour of \e{CS} is defined by the inifinite-state transition system \e{TS} = (\e{C}, $\rightarrow$) where
\begin{itemize}
\item[]
   \e{C} = (\e{S} $\times$ $\xi$) is the set of its configurations, where $\xi$ is an evaluation of the set of channels \e{Ch} in \e{CS}.
\item[]
  $\rightarrow$ $\subseteq (C \times C)$  is the smallest transition relation defined as follows:
  \begin{itemize}
    \item
      For each observable action a $\in$ \e{A} in \e{CS} \todo[inline]{Comment was ``this notation was not used previously'' on a specific part below ($\xrightarrow{a}$). Actually, none of this notation is really explained, and it is likely the reader has not seen them before. Should I add a section on how to read this?}
      \[
      \dfrac{s \xrightarrow{a} s'}{(S, \xi) \rightarrow (S', \xi)}
      \]
    \item
      For each transmission action $\langle s_1, ch!m, s_2 \rangle$ in \e{CS}
      \[
      \dfrac{s \xrightarrow{ch!m} s' \wedge \xi(ch) = m_1...m_n}{(S, \xi) \rightarrow (S', \xi')} \] with \[ \xi' = \xi[ch := m_1...m_n] \bullet m].
      \]
    \item
      For each reception action $\langle s_1, ch?m, s_2 \rangle$ in \e{CS}
      \[
      \dfrac{s \xrightarrow{ch?m} s' \wedge \xi(ch) = m \bullet m_1...m_n}{(S, \xi) \rightarrow (S', \xi')} \] with \[ \xi' = \xi[ch:= m_1...m_n].
      \]
    \item
      Additionally, a message can be lost on a channel.
      \[
      \dfrac{s \xrightarrow{ch*} s' \wedge \xi(ch) = m_1...m_{i-1} \bullet m_i \bullet m_{i+1}...m_n}{(S, \xi) \rightarrow (S', \xi')} \] with \[ \xi' = \xi[ch:= m_1...m_{i-1},m_{i+1}...m_n].
      \]

  \end{itemize}
\end{itemize}

At times we may use a notation for a configuration \e{c} with explicit processes and channels, so that \e{c} = $\conf{s_1,...,s_n, ch_1,...,ch_p}$, or alternatively, with explicit processes and channel evaluations, \e{c} = $(s_1,...,s_n, \xi(ch_1),...,\xi(ch_p))$.

\subsubsection{Traces}
\label{traces}
Suppose $s_n$ is a bad state of a channel system \e{CS}. Then a \e{bad trace} is a sequence \e{t} = $s_0s_1...s_n$ such that for each $0 \leq i \leq (n-1)$, $\conf{s_i,r,s_{i+1}}$ $\in$ $\delta$. If \e{t} is the shortest bad trace in the system, we call it a \e{minimal bad trace}.


\subsection{Alternating Bit Protocol}
Here we present a simple protocol, the \emph{alternating bit protocol}~\cite{bartlett1969note}. This protocol will serve as a running example of the theoretical concepts in this section and following sections.

The Alternating Bit Protocol (ABP)\todo{reference, and pseudo-code} is a distributed protocol for transmitting data from a \e{sender} to a \e{receiver} in a network. The protocol uses two unbounded channels, $ch_M$ used to transmit messages and $ch_A$ to transmit \e{acknowledgements} of received messages. The sender sends a message with sequence number \e{x} $\in$ \{0,1\} to the receiver over channel $ch_M$, who upon reception sends an acknowledgement with the same sequence number over channel $ch_A$. Both the sender and the receiver may send the same message (with the same sequence number) repeatedly. When the sender receives an acknowledgement from the receiver, the next message can be sent using the sequence number \e{1-x}, hence the name Alternating Bit Protocol.

This is a simple protocol that operates on unbounded channels. The behaviour of the sender and receiver process are illustrated in figures \ref{fig:in1} and \ref{fig:in2}, and the pseudo-code for the algorithm is seen below.

\begin{algorithm}
  \caption{ABP Sender}
  \label{senderpseudo}
\begin{algorithmic}[1]
    \State b := False \Comment{Initially False}
    \For{\texttt{$True$}}
      \State msg.send(data, b);
      \While{ack.receive().b != b} \Comment{Wait until ack has the correct ID}
      \State msg.send(data, b); \Comment{Re-send the message}
      \EndWhile
      \State b := !b \Comment{Alternate the bit}
    \EndFor
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
  \caption{ABP Receiver}
  \label{senderpseudo}
\begin{algorithmic}[1]
    \State b := False \Comment{Initially False}
    \For{\texttt{$True$}}
      \While{msg.receive().b != b} \Comment{Wait until msg has the correct ID}
      \State ack.send(data, b); \Comment{Re-transmit the acknowledgement}
      \EndWhile
      \State b := !b \Comment{Alternate the bit}
    \EndFor

\end{algorithmic}
\end{algorithm}
\ref{abpgraph}.

\begin{figure}[h!]
\subfloat[Sender]{\label{fig:in1}
\abpsender{}
}
\subfloat[Receiver]{\label{fig:in2}
\abpreceiver{}
}
\caption{Program graphs of sender and receiver in the ABP protocol.}
\label{abpgraph}
\end{figure}

\paragraph{Syntax.} The alternating bit protocol can be described by a channel system \e{CS} = $\langle S,s_0,A,Ch,M,\delta\rangle$ such that \e{S} = \{(s,r)\} with \e{s} $\in$ $\{s_1,s_2,s_3,s_4\}$, \e{r} $\in$ $\{r_1,r_2,r_3,r_4\}$, $s_0$ is the initial state ($s_1$,$r_1$), \e{A} = \{\e{Snd}, \e{Rcv}\}, \e{Ch} = \{$Ch_M,Ch_A$\}, \e{M} = \{1,0\} and $\delta$ is the set of transitions

\begin{ttabular}
$\langle s_1, Snd, s_2\rangle$ &
$\langle s_2, ch!0, s_2\rangle$ &
$\langle s_2, ch?1, s_2\rangle$ &
$\langle s_2, ch?0, s_3\rangle$ &
$\langle s_3, Snd, s_4\rangle$ &
$\langle s_4, ch!1, s_4\rangle$&
$\langle s_4, ch?0, s_4\rangle$&
$\langle s_4, ch?1, s_1\rangle$ \\

$\langle r_1, ch!1, r_1\rangle$ &
$\langle r_1, ch?1, r_1\rangle$&
$\langle r_1, ch?0, r_2\rangle$&
$\langle r_2, Rcv, r_3\rangle$&
$\langle r_3, ch!0, r_3\rangle$&
$\langle r_3, ch?0, r_3\rangle$&
$\langle r_3, ch?1, r_4\rangle$&
$\langle r_4, Rcv, r_1\rangle$
\end{ttabular}

\paragraph{Semantics and Notation.}
Let $c = \conf{S,\xi}$ be a configuration of the alternating bit protocol, with the channels containing the words 01 and 10 respectively. Then \e{c} may also be denoted as $c = \conf{s,r,ch_M,ch_A}$ or as $c = \conf{s_1,s_2,01,10}$. There are finitely many control states in this system (($s_i$,$r_j$) with i,j $\in$ \{1..4\}), but an infinite set of channel evaluations. A transmission transition in this system is for example $\langle\conf{s_2,r_1,01,10}$, $ch_m!1$, $\conf{s_2,r_1,011,10}\rangle$.




\subsubsection{Reachability and Bad Configurations}
\label{bad}
An instance of the \e{reachability problem} is defined by a channel transition system \e{TS} = $\conf{S,\xi}$, an initial configuration \e{I} and a set \e{Bad} $\subseteq$ $S$ of \e{bad configurations}. We assume that \e{Bad} is the upward closure $\{c$ | $ c \in B: b \sqsubseteq c\}$ of a given \e{finite} set of \e{minimal bad configurations}.

We use $\mathcal{R}$ to denote the set of reachable states, where a configuration \e{c} is said to be \emph{reachable} in \e{TS} ($c \in \mathcal{R}$), if there are configurations $c_1...c_l$ such that $c_0$ is an initial configuration of \e{TS} and for each 0 $\leq$ i < l, $c_i, \rightarrow c_{i+1}$. \todo{Does this not count as a formal definition for $\mathcal{R}$?} We say that the system \e{TS} is \e{safe} if there are no reachable bad configurations, i.e.  $\mathcal{R} \cap Bad$  = $\emptyset$.
