\section{Formal Model for Lossy Channel Systems}
\label{definitions}
In this chapter we will give the formal definition of a channel system. First we define some necessary terminology, such as alphabets and words, before giving the syntax and semantics of a channel system. Then we illustrate these ideas by applying them to a well-known communication protocol, the \emph{alternating bit protocol}. Finally, we state the formal definition of the verification problem we are investigating.

\subsection{Preliminaries}
\subsubsection{Words and Alphabet}
\todo[inline]{I realized that using merely messages and words does not suffice: The sender might send the string "abc" as a single message, whereas the receiver can read this message as "a" then "b" then "c", i.e. splitting that message. So message is basically just a word.}
An \emph{alphabet} $\Sigma$ is a finite set of \e{tokens}. We call a sequence $w$ of tokens a \e{word}, i.e. $w$ = $w_1, w_2..., w_n$ is a word containing the tokens $w_1,...,w_n \in \Sigma$. We define the \e{length} of a word to be the number of tokens in the word, for example, the length of $w$ = $w_1, w_2..., w_n$ is $n$. We use $\Sigma^*$ to denote the set of all possible words over an alphabet, $\Sigma^+$ to denote the set of all words of $\Sigma^*$ of finite length, and $\Sigma_k^+$ to denote all words of $\Sigma^+$ of length \e{at most} $k$. Further we let $\varepsilon$ be the \e{empty word} s.t. $\varepsilon \in \Sigma$, and having the length 0.

\todo[inline]{The missing subword ac is not a mistake. I'm not sure I can argue why it should not be there (can't remember if I need it not to be). In case I need to stick with the definition below, should I then use another symbol that $\subword$?}

Let $\subword$ be the subword relation, then \e{u} $\subword$ $w_1...w_n$=\e{w} iff \e{u} is an ordered subset of \e{w}. For example, if \e{w}=abc, then the set of subwords of \e{w} is {abc, ab, bc, a, b, c}.

\subsubsection{Guarded Transitions}
\todo[inline]{Potentially a section on how to read the transition relation notations used below.}

\subsection{Lossy Channel Systems}
\subsubsection{Syntax}
We present here the syntax of a finite-state system with unbounded channels. Such a system can be seen as to having two parts, a \e{control part} and a \e{channel part}. The channel part is a set of \e{channels} containing a word, which may be $\varepsilon$. The control part is a labeled finite-state transition system.

\label{CS}
Formally, a lossy channel system \emph{LCS} over a set of processes \e{P}, channels \e{Ch} and messages \e{M} is a triple $\conf{P,Ch,M}$, where
\begin{itemize}
\item[] $P = (p_0,p_1...p_n)$ is a finite set of processes $p_i$ = $(S_i, s_i^0, A_i, \delta_i)$ such that,
  \begin{itemize}
    \item $S_i$ is a finite set of control states
    \item $s_i^0$ is the initial control state
    \item $A_i$ is a set of labeled actions \todo{Do I really need nop? == label with empty string}
    \item $\delta_i$ is a finite set of transitions, each of which is a triple of the form $\langle s_i,op,s_i'\rangle$, where $s_i, s_i'\in S_i$ are control states, and $op$ is a label of one of the forms
    \begin{itemize}
      \item \e{ch!m}, where \e{ch} $\in$ \e{Ch} and \e{m} $\in$ \e{M}
      \item \e{ch?m}, where \e{ch} $\in$ \e{Ch} and \e{m} $\in$ \e{M}
      \item \e{a} $\in$ \e{A}.
    \end{itemize}
\end{itemize}
\item[] \e{Ch} is a finite set of channels,
\item[] $M \subset \Sigma^+$ is a finite set of messages (words) over a finite alphabet $\Sigma$,
\end{itemize}

The finite-state control part of \e{LCS} is set of processes \e{P}, each with an initial state $s_i^0$, labeled actions $a_i$ and transitions $\delta_i$. The channel part is represented by the set \e{Ch} of channels, which contain a possibly empty word from $M^+$. The set $A_i$ denotes the set of internal transitions, which only alter the internal state of a process. $\delta_i$ may either be an action from $A_i$, or an action where

\begin{itemize}
\item[]
$\langle s_i, ch!m, s_i'\rangle$ represents a change of state from $s_i \in S_i$ to $s_i'$ $\in S_i$ while appending the message $m\in M$ to the tail of channel $ch\in Ch$.
\item[]
$\langle s_i, ch?m, s_i'\rangle$ represents a change of state from $s_i\in S_i$ to $s_i'\in S_i$ while removing the message $m\in M$ from the head of channel $ch \in Ch$
\end{itemize}

\subsubsection{Configuration}
Let $\xi : ch \rightarrow \Sigma^*$ be a function that maps the content of a channel $ch \in Ch$ to the word on the channel. We will call this the \emph{evaluation} of the channel. We define a \e{configuration} to be a tuple $C$ = $(s, W)$, such that

\begin{itemize}
  \item $s$ is the global control state:

   $s$ = $(s_1, s_2... s_n)$ s.t. $s_i \in S_i$ is the local control state $P_i$, $1 \leq i \leq n$.
  \item $W$ is an ordered set of channel evaluations: $W$ = $(W_1, W_2...W_m)$ s.t. $W_i$ = $\xi(ch_i)$ for a channel $ch_i \in Ch$, $1 \leq i \leq m$.
\end{itemize}

Let $\epsilon$ denote a sequence of empty words. We define $c^0$ to be the initial configuration $((s_1^0, s_2^0...s_n^0), \epsilon)$, i.e. the configuration with all processes in their initial state and all channel evaluations being the empty word.

\subsection{Semantics}
In the following section, we explain the semantics of a lossy channel system, which describes the behaviour of the system.
%A \e{transition system} is an abstract machine, commonly used in model checking to describe the behaviour of a system. They are in ways similar to the notion of finite state automata, with the difference that the states and transitions in a transition system need not be finite. A state of a transition system describing a program may be determined, for example, the evaluation of all variables in the program. Transitions describe how a system in a certain state can move to another state.

\paragraph{Definition}
\label{CTS}
The operational behaviour of \e{LCS} is defined by the inifinite-state transition system \e{LTS} = (\e{C}, $\rightarrow$) where
\begin{itemize}
\item[]
   \e{C} is a possibly infinite set of configurations
\item[]
  $\rightarrow$ $\subseteq (C \times C)$  is the smallest transition relation defined as follows:
  \begin{itemize}
    \item For each observable action $a_i$ $\in$ $\delta_i$ of $P_i \in P$
      $$\dfrac{s_i \xrightarrow{a_i} s_i'}{(s, W) \rightarrow (s', W)}$$
      s.t.
      $$s = (s_1...s_i...s_n) \rightarrow (s_1...s_i'...s_n) = s'$$
    \item For each transmission action $\langle s_i, ch_j!m, s_i' \rangle$ in $\delta_i$ of $P_i \in P$
      $$\dfrac{s \xrightarrow{ch_j!m} s' \wedge W_j = m_1...m_n}{(s, W) \rightarrow (s', W')}$$
      s.t.
      $$W_j' = m_1...m_n \bullet m, W_i = W_i' \forall i \neq j$$ and $$s = (s_1...s_i...s_n) \rightarrow (s_1...s_i'...s_n) = s'$$
    \item For each reception action $\langle s_i, ch_j?m, s_2 \rangle$ in $\delta_i$ of $P_i \in P$
      $$\dfrac{s \xrightarrow{ch_j?m} s' \wedge W_j = m_1...m_n}{(s, W) \rightarrow (s', W')}$$
      s.t
      $$W_j' = m_2...m_n, W_i = W_i' \forall i \neq j$$ and $$s = (s_1...s_i...s_n) \rightarrow (s_1...s_i'...s_n) = s'$$
    \item
      Additionally, a message can be non-deterministically lost on a channel:
      $$\dfrac{s \xrightarrow{ch_j^*} s \wedge W_j = m_1...m_{i-1} \bullet m_i \bullet m_{i+1}...m_n}{(s, W) \rightarrow (s, W')}$$
      s.t.
      $$W' = m_1...m_{i-1},m_{i+1}...m_n$$
      \todo[inline]{Missing the synchronization-transition right now}
  \end{itemize}
\end{itemize}

\paragraph{Notations for configurations}
Depending on the context, different notations to describe a configuration $c\in C$ may be used. For example, c = (s, W) can be denoted as \e{c} = $\conf{s, ch_1,...,ch_p}$, \e{c} = $\conf{s_1,...,s_n, W}$, \e{c} = $\conf{s_1,...,s_n, ch_1,...,ch_p}$.

\subsection{Alternating Bit Protocol}
Here we present a simple protocol, the \emph{alternating bit protocol}~\cite{bartlett1969note}. This protocol will serve as a running example of the theoretical concepts in this section and following sections.

The Alternating Bit Protocol (ABP)\todo{reference, and pseudo-code} is a distributed protocol for transmitting data from a \e{sender} to a \e{receiver} in a network. The protocol uses two unbounded channels, $ch_M$ used to transmit messages and $ch_A$ to transmit \e{acknowledgements} of received messages. The sender sends a message with sequence number \e{x} $\in$ \{0,1\} to the receiver over channel $ch_M$, who upon reception sends an acknowledgement with the same sequence number over channel $ch_A$. Both the sender and the receiver may send the same message (with the same sequence number) repeatedly. When the sender receives an acknowledgement from the receiver, the next message can be sent using the sequence number \e{1-x}, hence the name Alternating Bit Protocol.

This is a simple protocol that operates on unbounded channels. The behaviour of the sender and receiver process are illustrated in figures \ref{fig:in1} and \ref{fig:in2}, and the pseudo-code for the algorithm is seen below.

\begin{algorithm}
  \caption{ABP Sender}
  \label{senderpseudo}
\begin{algorithmic}[1]
    \State b := False \Comment{Initially False}
    \For{\texttt{$True$}}
      \State msg.send(data, b);
      \While{ack.receive().b != b} \Comment{Wait until ack has the correct ID}
      \State msg.send(data, b); \Comment{Re-send the message}
      \EndWhile
      \State b := !b \Comment{Alternate the bit}
    \EndFor
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
  \caption{ABP Receiver}
  \label{senderpseudo}
\begin{algorithmic}[1]
    \State b := False \Comment{Initially False}
    \For{\texttt{$True$}}
      \While{msg.receive().b != b} \Comment{Wait until msg has the correct ID}
      \State ack.send(data, b); \Comment{Re-transmit the acknowledgement}
      \EndWhile
      \State b := !b \Comment{Alternate the bit}
    \EndFor

\end{algorithmic}
\end{algorithm}
\ref{abpgraph}.

\begin{figure}[h!]
\subfloat[Sender]{\label{fig:in1}
\abpsender{}
}
\subfloat[Receiver]{\label{fig:in2}
\abpreceiver{}
}
\caption{Program graphs of sender and receiver in the ABP protocol.}
\label{abpgraph}
\end{figure}

\paragraph{Syntax.} The alternating bit protocol can be described by a channel system \e{CS} = $\langle S,s_0,A,Ch,M,\delta\rangle$ such that \e{S} = \{(s,r)\} with \e{s} $\in$ $\{s_1,s_2,s_3,s_4\}$, \e{r} $\in$ $\{r_1,r_2,r_3,r_4\}$, $s_0$ is the initial state ($s_1$,$r_1$), \e{A} = \{\e{Snd}, \e{Rcv}\}, \e{Ch} = \{$Ch_M,Ch_A$\}, \e{M} = \{1,0\} and $\delta$ is the set of transitions

\todo[inline]{I refrain from updating these until we've settled for a final version of the syntax and semantics}

\begin{ttabular}
$\langle s_1, Snd, s_2\rangle$ &
$\langle s_2, ch!0, s_2\rangle$ &
$\langle s_2, ch?1, s_2\rangle$ &
$\langle s_2, ch?0, s_3\rangle$ &
$\langle s_3, Snd, s_4\rangle$ &
$\langle s_4, ch!1, s_4\rangle$&
$\langle s_4, ch?0, s_4\rangle$&
$\langle s_4, ch?1, s_1\rangle$ \\

$\langle r_1, ch!1, r_1\rangle$ &
$\langle r_1, ch?1, r_1\rangle$&
$\langle r_1, ch?0, r_2\rangle$&
$\langle r_2, Rcv, r_3\rangle$&
$\langle r_3, ch!0, r_3\rangle$&
$\langle r_3, ch?0, r_3\rangle$&
$\langle r_3, ch?1, r_4\rangle$&
$\langle r_4, Rcv, r_1\rangle$
\end{ttabular}

\paragraph{Semantics and Notation.}
Let $c = \conf{S,\xi}$ be a configuration of the alternating bit protocol, with the channels containing the words 01 and 10 respectively. Then \e{c} may also be denoted as $c = \conf{s,r,ch_M,ch_A}$ or as $c = \conf{s_1,s_2,01,10}$. There are finitely many control states in this system (($s_i$,$r_j$) with i,j $\in$ \{1..4\}), but an infinite set of channel evaluations. A transmission transition in this system is for example $\langle\conf{s_2,r_1,01,10}$, $ch_m!1$, $\conf{s_2,r_1,011,10}\rangle$.

\subsubsection{The Verification Problem}
A channel system can potentially result in a \e{bad} state, i.e. a state representing unintended behaviour. Suppose $Bad$ is a set of bad configurations of a channel system \e{LTS}. Let a \e{trace} be a sequence \e{t} = $c^0c^1...c^n$ such that for each $0 \leq i \leq (n-1)$, $\conf{c^i,c^{i+1}}$ $\in$ $\rightarrow$. If $c^n \subseteq c_bad$ for any $c_bad \in Bad$, we call such a trace a \e{bad trace}. Note that a configuration with a bad control state is a bad configuration, regardless of the content of the channel evaluation. If \e{t} is the shortest bad trace in the system, we call it a \e{minimal bad trace}.

Let $\mathcal{R}$ denote the set of all reachable configurations. A configuration \e{c} is said to be \emph{reachable} in \e{LTS} ($c^l \in \mathcal{R}$), if there is a trace from initial configuration $c^0$ to $c^l$. The verification problem is to determine, for a channel transition system \e{LCS} = $\conf{s,W}$ with an initial configuration $c^0$ and a set \e{Bad} $\subseteq$ $S$ of bad configurations, whether a system is safe, that is, does not have any reachable bad configurations. More precisely, this means determining if $\mathcal{R} \cap Bad$  = $\emptyset$.


%A channel system can potentially result in a \e{bad} state, i.e. a state representing unintended behaviour. Suppose $Bad$ is a set of bad control states of a channel system \e{LTS}. Let a \e{trace} be a sequence \e{t} = $c^0c^1...c^n$ such that for each $0 \leq i \leq (n-1)$, $\conf{c^i,c^{i+1}}$ $\in$ $\rightarrow$. If $c^n$ = $(s_bad, W)$ s.t. $s_bad \in Bad$, we call such a trace a \e{bad trace}. Note that a configuration with a bad control state is a bad configuration, regardless of the content of the channel evaluation. If \e{t} is the shortest bad trace in the system, we call it a \e{minimal bad trace}.

%Let $\mathcal{R}$ denote the set of all reachable configurations. A configuration \e{c} is said to be \emph{reachable} in \e{LTS} ($c^l \in \mathcal{R}$), if there is a trace from initial configuration $c^0$ to $c^l$. The verification problem is to determine, for a channel transition system \e{LCS} = $\conf{s,W}$ with an initial configuration \e{c^0} and a set \e{Bad} $\subseteq$ $S$ of bad control states, whether a system is safe, that is, does not have any reachable bad configurations. More precisely, this means determining if $\mathcal{R} \cap Bad$  = $\emptyset$.




%I MIGHT WANT THIS AGAIN
%We assume that \e{Bad} is the upward closure $\{c$ | $ c \in B: b \sqsubseteq c\}$ of a given \e{finite} set of \e{minimal bad configurations}.
