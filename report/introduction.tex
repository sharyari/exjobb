\newpage
\section{Introduction}
Todays society grows more and more dependent on computer applications\todo{Do you mean I should have a reference for this?}. Often they are used directly, for example the task of paying bills online. In other cases, applications are aiding us in a more abstract manner, e.g. controlling the elevator or planning a train schedule. The common factor between the online bank, the elevator relay and the train scheduler is that the correctness of these programs is of utter importance, where program failure could have devastating results on the economy, the infrastructure or even cause harm.

This has motivated research on various techniques to find and correct potential faults, particularly in safety-critical systems. The most common technique is that of \e{testing}, i.e. observing the system behaviour on a variety of likely or even unlikely scenarios. The widespread use of testing is well-motivated, but there are several scenarios, where testing by itself is insufficient, or difficult to carry out. It would for example be costly to verify the correctness of the aforementioned elevator only by testing, as a failure could result in damages on the system.

A technique used for verification is the process of \e{simulation}. In contrast to testing, simulation can be done in an early stage of the development. Rather than first implementing an algorithm, one may simulate an abstracted model of the algorithm which may help in ensuring its correctness or find a fault in the algorithm before development has begun. An important note is that simulation techniques are not intended to be used \e{instead} of testing, but rather in combination with testing, as an abstract model of a system can never fully represent the system as a whole.

A trend in todays computing is that applications become concurrent or distributed. Such programs are inherently difficult to verify, due to the fact that although processes themselves have finite models, the results of the behaviour of asynchronous processes may be infinite. This is the case for example when the composition of a possibly infinite number of processes is observed, a common scenario when verifying  concurrent and distributed programs. Also, we are often not interested in performing verification of a \e{specific} composition of concurrent programs, but rather in verifying that it works for \e{all} compositions.

Related to this is the necessity for distributed and concurrent programs to communicate, and to do so accurately. In general, the underlying systems that we use for our communication are inreliable, in that message loss or message corruption may occur. This happens due to a variety of reasons, may that be faults in the communication links, relays or the communicating parties themselves. To overcome this problem, communication protocols are designed to be resistent to such faults, and ensuring the correctness of these protocols is paramount when ensuring reliable communication. Even when the number of communicating processes is finite, communication protocols commonly result in infinte models, as the number of sent messages may be unbounded, and there may be an infinite number of orderings thereof. The verification of such systems, which rely on communication channels, is the focus of this thesis.

The goal of \e{model checking} is to formally verify the correctness of concurrent programs with respect  to a given specification. In general, given a model of a system and a specification of its intended properties, the task is to decide whether a model meets its specification or not.

Different representations of models and properties have been proposed, as well as techniques to perform the verification. One of the most successful and most common methods is that of \e{temporal logic model checking}. Traditionally, the model is expressed as a finite state machine and the properties as propositional logic formulae. Several verification methods for such models have been proposed\cite{mcmillan1993symbolic} and although these methods have been applied to infinite models\cite{705644}, the focus has in large been on the verification of finite models.

Another approach is taken by \cite{parosh}, in which the verification of \e{parameterized systems} is attempted. \e{Parameterized systems} are systems composed of a set of processes, where the number of processes is itself a parameter of the system. This is often the case when discussing concurrent and distributed programs. Although an undecidable problem, there are methods that can provide approximation techniques that allows us to reduce the verification task to the finite state case. These methods include \e{counter abstraction techniques}\cite{counterabstraction} and \e{invisible invariant} generation\cite{invinv}. 

In \cite{parosh}, the authors take advantage of the \e{small model property} -- if a small instance of a system is enough to exhibit the relevant behaviour of the system as a whole, that instance is a small model of the system\todo[inline]{Didn't understand the comment regarding this}. An important contribution of \cite{parosh} is that they show that this property holds for \e{quasi well-ordered systems}\cite{abdulla2010} (i.e. transitions systems monotonic with respect to a well-quasi ordering)\todo[inline]{is this good enough, or did I just explain it in a circle?}, and indicates its use for yet larger sets of systems.

Using well-known techniques of \e{abstract interpretation} combined with the idea of small models, \cite{parosh} shows that parameterized systems can in fact be reduced to finite and decidable approximations of the system, and a prototype implementation of the technique substantiates this claim by empirical results.

This essay draws the attention towards systems relying on communications over asynchronous unbounded buffers. This scenario is common in communication protocols using channels and in distributed computing\cite{fredlund2007mcerlang}. An important note is that channel systems working on \e{perfect channels} are Turing powerful\todo[inline]{Why powerful and not complete? difference?}, and therefore undecidable, but it has been shown that verification of safety properties of channel systems over \e{lossy channels}, i.e. channels that may nondeterministicly lose messages, is decidable\cite{287591}\cite{gordon}. Channels systems need not only represent communication protocols, but may also be used to described other types of programs, such as cache coherence protocols and sensor systems\cite{zuck2004}.

Inspired by \cite{parosh}, I explore the possibility of using abstract interpretation techniques and small models for systems with unbounded buffers, keeping the number of programs constant. We developed a verification technique for this purpose and the resulting model was implemented and tested. 

%As previously mentioned, this is an undecidable problem in general, and this paper does \e{not} investigate exactly what class of systems that are decidable. The experimental results show that several well-known communication protocols are indeed in the scope of the tool.

%% Is this actually a decidable problem?

\paragraph{Reading this paper} Section \ref{notation} introduces some of the terminology and notation used in this paper, whereas section \ref{definitions} contains formal definitions to some of the key concepts -- these are previously known concepts, asides from their adaption to the specific context of this thesis. Section \ref{model} introduces the concepts of small models and abstract interpretation, and relates these to buffer channels to create the theoretical model for this paper. Section \ref{extensions} introduces some extensions to this model, allowing for a wider variety of modeling scenarios. In section \ref{implementation}, some abstractions and techniques are explained that allow for an efficient implementation of the verification algorithm. Further a protocol specification language is explained, that allows a user to define and use the verification tool without knowledge of the intricacies of the internal model. The results of the verifier when applied to a number of well-known communication algorithms is presented in section \ref{results}, as well as some comparisons against the results of other verification tools.

 	

%%% Local Variables:
%%% TeX-master: "report"
%%% End:
