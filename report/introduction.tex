\newpage
\section{Introduction}
Todays society grows more and more dependent on computer applications. Often they are used directly, for example the task of paying one's bills online. In other cases applications are aiding us in a more abstract manner, e.g. controlling the elevator or planning a train schedule. The common factor between the online bank, the elevator relay and the train scheduler is that the correctness of these programs is of utter importance, where program failure could have devastating results on the economy, the infrastructure or even cause the loss of human life.

This has motivated research on various techniques to find and correct potential faults, particularly in safety-critical systems. The most common technique is that of \e{testing}, i.e., observing the system behaviour on a variety of likely or even unlikely scenarious. The widespread use of testing is well-motivated, but there are several scenarios, where testing by itself is insufficient, or difficult to carry out. It would for example be costly to verify the correctness of the aforementioned elevator only by testing, as a failure could result in damages on the system. Yet another weakness of this approach is that testing helps find faults at a late stage in the development process.

Another technique used for verification is the process of \e{simulation}. In contrast to testing, simulation can be done in an early stage of the development. Rather than first implementing an algorithm, one may simulate an abstracted model of the algorithm which may help ensure its correctness or find a fault in the algorithm before development has begun. An important note is that simulation techniques are not intended to be used \e{instead} of testing, but rather in combination with testing, as an abstract model of a system can never fully represent the system.

The goal of \e{formal verification} or \e{model checking} is to formally verify the correctness of concurrent programs with respect to a given specification. It builds upon the fact that programs can be defined as logical formulaes, and thus, their correctness can be established using logical proofs. Although manual proofs have been and are still being used, most research efforts of formal verification today are directed against automatic verification methods.

In general, given a model of a system and a specification of its properties, the task is to decide whether or not a model meets its specification, by performing an exhaustive search in the system. Although different ways of representing the model and the properties have been proposed\todo{citation needed}, most commonly the model is expressed as a \e{finite state machine} and the properties as propositional logic formulae. These properties are then checked by creating a \e{transition system} corresponding to the FSM at hand.\todo{FSM becomes TS, prop. logic becomes LTL/CTL?}

A serious limitation of model checking is the problem of \e{state space explosion}, i.e. an exponential increase of states in the transition system, in relation to the size of the finite state machine, i.e. if a model describes a system with \e{n} concurrent programs, its transition system may be of exponential size in respect of n. An issue similar to that of the state space explosion is the fact that a transition system corresponding to a finite state model need not itself be finite. This happens for example when the transition system is the composition of an infinite number of FSMs, but even such programming artifacts as using an unbounded integral value or relying on a buffer may introduce an infinit aspect into the model.

This essay focuses on this latter point; model checking systems communicating over asynchronous unbounded buffer, a scenario common in, but not bounded to, the verification of communication algorithms. An important note is that channel systems working on \e{perfect channels} are turing complete, and therefore undecidable, but it has been shown that model checking of channel systems over \e{lossy channels} is decidable\cite{287591}\cite{Bertrand:2003:MCL:1754809.1754819}.

Based on previous work by Parosh et al. \todo{Do I really wanna use this type of references? also, add the actual reference}, I develop a system that in many cases is capable of reducing the inifinte state space of a lossy buffer system to a finite set of \e{configurations}. Section \ref{definitions} contains a formal definition of such a parameterized system. Section \ref{extensions} contains a few extensions to this model, allowing for a wider variety of modelling scenarios. In section \ref{model}, some abstractions and techniques are examplained that allow for an efficient implementation of the verification algorithm. Further a protocol specification language is explained, that allows a user to define and use the verification tool without, without knowledge of the intricacies of the internal model. The results of the verifier when applied to a number of well-known communication algorithms is presented in section \ref{results}, as well as some comparisons against the results of other verification tools.

