\newpage
\section{Introduction}
Todays society grows more and more dependent on computer-applications. Often they are used directly, for example the task of paying one's bills online, in other cases applications are aiding us in a more abstract manner, e.g. controlling the elevator or planning a train schedule. The common factor between the online bank, the elevator relay and the train scheduler is that the correctness of these programs is of utter importance, where program failure could have devastating results on the economy, the infrastructure or even cause the loss of human life.

This has motivated research on various techniques to find and correct potential faults pre-deployment. The most common technique is that of \e{testing}, i.e., observing the system behaviour on a variety of likely or even unlikely scenarious. The widespread use of testing is well-motivated, but there are several scenarios, where testing by itself is not enough or maybe not even possible. It would for example be costly to verify the correctness of the aforementioned elevator only by testing, as a failure could result in damages on the system. Yet another weakness of this approach is that testing helps find faults at a late stage in the development process.

Another technique used for verification is the process of \e{simulation}. In contrast to testing, simulation can be done in an early stage of the development. Rather than first implementing an algorithm, one may simulate an abstracted model of the algorithm which may help ensure its correctness or find a fault in the algorithm before development has begun. An important note is that simulation techniques are not intended to be used \e{instead} of testing, but rather in combination with testing, as an abstract model of a system can never fully represent the system.

The goal of \e{formal verification} or \e{model checking} is to formally verify the correctness of a program with respect to a given specification. In general, given a model of a system and a set of properties, the task is to decide whether the properties are met by the model or not, by performing an exhaustive search in the system. Although different ways of representing the model and the properties have been proposed\todo{citation needed}, most commonly the model is expressed as a \e{finite state machine} and the properties as propositional logic formulae. These properties are then checked by creating a \e{transition system} corresponding to the FSM at hand.\todo{FSM becomes TS, prop. logic becomes LTL/CTL?}

A serious limitation of model checking is the problem of \e{state space explosion}, i.e. an exponential increase of states in the transition system, in relation to the size of the finite state machine. Related to this is the fact that a transition system need not even be finite, for example when the transition system is the composition of an infinite number of FSMs, but even such programming artifacts as using an unbounded integral value or relying on a buffer may introduce an infinit aspect into the model.

This essay focuses on this latter point; model checking systems relying on an unbounded buffer. This scenario is common in, but not bounded to, the verification of communication algorithms. Based on previous work by Parosh et al. \todo{Do I really wanna use this type of references? also, add the actual reference}, I develop a system that in many cases is capable of reducing the inifinte state space of a buffer system to a finite set of states. Section \ref{definitions} contains a formal definition of such a parameterized system. Section \ref{extensions} contains a few extensions to this model, allowing for a wider variety of modelling scenarios. In section \ref{model}, some abstractions and techniques are examplained that allow for an efficient implementation of the verification algorithm. Further a protocol specification language is explained, that allows a user to define and use the verification tool without, without knowledge of the intricacies of the internal model. The results of the verifier when applied to a number of well-known communication algorithms is presented in section \ref{results}, as well as some comparisons against the results of other verification tools.

