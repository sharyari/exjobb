\newpage
\section{Introduction}
Todays society grows more and more dependent on computer applications. Often they are used directly, for example the task of paying bills online. In other cases, applications are aiding us in a more abstract manner, e.g. controlling the elevator or planning a train schedule. The common factor between the online bank, the elevator relay and the train scheduler is that the correctness of these programs is of high importance, where program failure could have devastating results on the economy, the infrastructure or even be harmful.

This has motivated research on various techniques to find and correct potential faults, particularly in safety-critical systems. The most common technique is that of \e{testing}, i.e. observing the system behaviour on a variety of likely or even unlikely scenarios. The widespread use of testing is well-motivated, but there are several scenarios where testing by itself is insufficient, as testing does not provide any formal guarantee of correctness.

Another technique used for verification is the process of \e{simulation}. In comparison to testing, simulation can be done in an earlier stage of the development. Rather than first implementing an algorithm, one may simulate an abstract model of the algorithm which may help ensure its correctness, or find a fault in the algorithm before development has begun. An important note is that simulation techniques are not intended to be used \e{instead} of testing, but rather in combination with testing, as an abstract model of a system can never fully represent the system as a whole.

The goal of \e{model checking} is to formally verify the correctness of programs with respect to a given specification. In general, given a model of a system and a specification of its intended properties, the task is to decide whether the model meets its specification or not.

Different representations of models and properties have been proposed, as well as techniques to perform the verification. One of the most successful and common methods is that of \e{temporal logic model checking}. Traditionally, the model is expressed as a finite state machine and the properties as propositional logic formulae. Several verification methods for such models have been proposed\cite{mcmillan1993symbolic} and although these methods have been applied to infinite models\cite{705644}, the focus has in large been on the verification of finite models.

A trend in todays computing is that applications become concurrent or distributed. Such programs are inherently difficult to verify; although processes themselves have finite models, the results of the asynchronous behaviour of processes may be infinite. This is the case, for example, when the composition of a possibly infinite number of processes is observed -- a common scenario when verifying concurrent and distributed programs. Also, we are often not interested in performing verification of a \e{specific} composition of concurrent programs, but rather in verifying that it works for \e{all} compositions.

Related to this is the necessity for distributed and concurrent programs to communicate, and to do so accurately. In general, the underlying systems that we use for our communication are unreliable, in that message loss or message corruption may occur. This happens due to a variety of reasons, may that be errors in the communication links, relays or the communicating parties themselves. To overcome this problem, communication protocols are designed to be resistent to such faults, and ensuring the correctness of these protocols is paramount when ensuring reliable communication. Even when the number of communicating processes is finite, communication protocols commonly result in infinite models, as the number of sent messages may be unbounded. It is therefore possible for an infinite number of messages to be in the communication buffer. The verification of systems relying on asynchronous unbounded buffers, is the focus of this thesis.

Such \emph{channel systems}, i.e. systems dependent on communication buffers, are common in communication protocols using channels and in distributed computing\cite{fredlund2007mcerlang}. Channel systems may also be used to represent other types of programs, such as cache coherence protocols and sensor systems\cite{zuck2004}. An important note is that channel systems using \e{perfect channels}, i.e. channels without message loss, are Turing powerful, and all non-trivial problems are therefore undecidable. However it has been proven that verification of \emph{safety properties} of channel systems over \e{lossy channels}, i.e. channels that may nondeterministicly lose messages, is decidable\cite{287591}\cite{gordon}. Nevertheless, the problem is difficult to verify, having high computational complexity.

The main problem when verifying such systems is to find a way to construct a finite approximation of the infinite system. In order to solve this problem, we find inspiration in \cite{parosh}, where the verification of \e{parameterized systems} is attempted. \e{Parameterized systems} are systems composed of a set of processes, where the number of processes is itself a parameter of the system -- this is often the case when discussing concurrent and distributed programs. Although the verification of such systems is an undecidable problem, there are methods that provide good approximation techniques which consist in reducing the verification task to the case of finite state systems.

In \cite{parosh}, the authors take advantage of the fact that parameterized systems often enjoy a \e{small model property}, meaning that the verification of small instances of the system is enough to capture the reachability of bad configurations. An important contribution of \cite{parosh} is that they show that this property holds for any \e{well-structured transition systems}\cite{abdulla2010} (i.e. transitions systems monotonic with respect to a well-quasi ordering).

%Using well-known techniques of \e{abstract interpretation} combined with the idea of small models, \cite{parosh} shows that parameterized systems can in fact be reduced to finite and decidable approximations of the system, and a prototype implementation of the technique substantiates this claim by empirical results.

Building upon the work in \cite{parosh}, we explore the possibility of adapting the verification algorithm proposed in \cite{parosh}, in order to verify systems with unbounded lossy channels.

The verification algorithm is based on an enumerative exploration of all the finite approximations by bounding the size of the channels. To verify each bounded instance of the system (let us assume that the size of the buffers is bounded by $k$ $\in$ $\mathds{N}$) we use a standard forward reachability algorithm. If the reachability analysis returns a counter-example, then this is a real counter-example of our system and the analysis procedure terminates. Otherwise, if the analysis procedure declares the finite approximation as safe, then we proceed to a second verification step. This extra verification step uses abstract interpretation techniques\cite{cousot1977}\cite{cousot1979}, with the goal to check wether $k$ is a \emph{cut-off} point, at which there is no need to verify any larger instance, and the program is safe. If the second step determines that the algorithm is safe, then the algorithm is truly safe for that instance and all larger instances. If, on the other hand, a counter-example is found, this means that the reachability analysis must be repeated, with the buffers bounded to size $k+1$.

As lossy channel systems are well-structured, the small model property holds for the classes of systems being considered in this thesis, thus a cut-off point will eventually be found, leaving a termination guarantee for the algorithm.

The verification technique was implemented and tested for some common communication protocols. The results were compared to that of two other verification techniques for the same classes of systems; the MPass\cite{mpass} verifier, which translates verification problems to satisfiability problems, solvable using third party SAT-solvers, and a \emph{backward reachability analysis} as described in \cite{287591}. The backward analysis algorithm was implemented within the scope of this project for the purpose of comparison. The experimental results confirm the correctness of the results, and show that the verification times are comparable or faster than the alternative methods for most of the verified protocols.

\paragraph{Reading this paper.} Section \ref{definitions} contains formal definitions of some of the key concepts -- these are previously known concepts adapted to the specific context of this thesis. Section \ref{model} introduces the concepts of small models and abstract interpretation, and relates these to buffer channels to create the theoretical model for this paper. 

In section \ref{naive}, a simple implementation of the verification algorithm is suggested. Sections \ref{improved1} and \ref{improved2} introduce some techniques and abstractions which allow for a more efficient implementation of the verification algorithm. Further a protocol specification language is introduced in section \ref{speclang}, which allows a user to define and use the verification tool without knowledge of the inner workings of the model. The results of the verifier when applied to a number of well-known communication algorithms is presented in section \ref{results}, as well as some comparisons against the results of other verification tools.




%%% Local Variables:
%%% TeX-master: "report"
%%% End:
